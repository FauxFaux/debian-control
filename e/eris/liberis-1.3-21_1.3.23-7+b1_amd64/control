Package: liberis-1.3-21
Source: eris (1.3.23-7)
Version: 1.3.23-7+b1
Architecture: amd64
Maintainer: Debian Games Team <pkg-games-devel@lists.alioth.debian.org>
Installed-Size: 893
Depends: libatlas-cpp-0.6-3 (>= 0.6.3), libc6 (>= 2.15), libgcc1 (>= 1:3.0), libmercator-0.3-4 (>= 0.3.0), libsigc++-2.0-0v5 (>= 2.8.0), libskstream-0.3-7v5 (>= 0.3.9), libstdc++6 (>= 5.2), libwfmath-1.0-1v5 (>= 0.3.11)
Section: libs
Priority: optional
Multi-Arch: same
Homepage: https://www.worldforge.org/
Description: WorldForge client entity library
 Eris is designed to simplify client development (and avoid repeating the
 same work several times), by providing a common system to deal with the
 back end tasks. Notably, Eris encapsulates most of the work in getting
 Atlas entities available on your client, logging into a server, and
 managing updates from the server. Thus it can be considered as a session
 layer above Atlas, providing persistent (for the session) objects as
 opposed to Atlas ones (which are transient). It handles the client-side
 implementation of the meta-server protocol, and querying game servers;
 out-of-game (OOG) operations (via the Lobby and Rooms), and most
 important in-game (IG) operations such as entity creation, movement and
 updates.
 .
 Eris provides a generic 'Entity' class, which you are free to sub-class
 and provide to the system (by registering a factory with the World);
 thus you are free to create different classes to handle characters,
 walls, vehicles, etc as your client dictates. An alternative approach is
 to simply create peer classes, and connect them to Eris via
 callbacks. Eris makes extensive use of libSigC++, which must be
 correctly installed and functioning on your system. Familiarity with
 signal/slot programming concepts is essential for using Eris; the
 libSigC++ home-page has some examples. Gtk+ or QT signal systems also
 provide a good introduction.
