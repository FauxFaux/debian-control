#!/bin/sh
# Debian wdm package pre-removal script
# Copyright 2001 Branden Robinson.
# Copyright 2005 Vladimir Shakhov.
# Licensed under the GNU General Public License, version 2.  See the file
# /usr/share/common-licenses/GPL or <http://www.gnu.org/copyleft/gpl.txt>.
# Acknowlegements to Stephen Early, Mark Eichin, and Manoj Srivastava.

set -e

THIS_PACKAGE=wdm
DEFAULT_DISPLAY_MANAGER_FILE=/etc/X11/default-display-manager

HAVE_DEBCONF=
if [ -e /usr/share/debconf/confmodule ]; then
  . /usr/share/debconf/confmodule
  HAVE_DEBCONF=yes
fi

message () {
  # pretty-print messages of arbitrary length
  echo "$*" | fold -s -w ${COLUMNS:-80} >&2;
}

message_nonl () {
  # pretty-print messages of arbitrary length (no trailing newline)
  echo -n "$*" | fold -s -w ${COLUMNS:-80} >&2;
}

errormsg () {
  # exit script with error
  message "$*"
  exit 1;
}

parseans () {
  if [ ! $1 ]; then
    echo $DEFAULT
  else
    echo $1 | cut -c1 | tr '[A-Z]' '[a-z]';
  fi;
}

trap "message ;\
      message 'Received signal.  Aborting wdm package prerm script.' ;\
      message ;\
      exit 1" 1 2 3 15

case "$1" in
  # we NEVER want to stop wdm without doing some checks first, see below
  upgrade|failed-upgrade)
    REMOVING=
    ;;
  remove|deconfigure)
    REMOVING=yes
    ;;
esac

STOP=
# are we supposed to restart on upgrade?  if REMOVING wdm, we don't care
if grep -qs ^restart-on-upgrade /etc/X11/wdm/wdm.options || [ -n "$REMOVING" ]; then
  # is there an wdm process running?
  if start-stop-daemon --stop --quiet --signal 0 --exec /usr/bin/wdm; then
    # any children?
    PARENTS=$(pidof /usr/bin/wdm || true)
    CHILDREN=
    for PROCESS in $PARENTS; do
      # make sure we got numbers back
      if ! [ $PROCESS -eq $PROCESS ] 2> /dev/null; then
        # freak out
        errormsg "ERROR: pidof returned non-numeric value!"
      fi
      # we could use grep -q here if ps would ignore SIGPIPE :-P
      if (ps axj | grep "^ *$PROCESS" > /dev/null 2>&1); then
        CHILDREN=yes
      fi
    done
    if [ -n "$CHILDREN" ]; then
      #message "WARNING: Preparing to stop WINGs display manager (wdm) daemon," \
       #       "and it appears to be managing at least one running X" \
        #      "session.  If wdm is stopped now, any X sessions it manages" \
       #       "will be terminated.  Otherwise you may leave wdm running," \
        #      "and the new version will take effect the next time wdm is" \
         #     "restarted."
      message "WARNING: Preparing to stop WINGs display manager (wdm) daemon"
      DEFAULT=n
      VALID_ANSWER=
      while [ -z "$VALID_ANSWER" ]; do
        #message_nonl "Do you wish to stop the wdm daemon? (y/n) [$DEFAULT] "
        #read ANSWER # because failed to tun
        ANSWER=y
        ANSWER=$(parseans $ANSWER)
        case "$ANSWER" in
          y) VALID_ANSWER=true; STOP=yes ;;
          n) VALID_ANSWER=true ;;
          *) message "\"$ANSWER\" not understood." ;;
        esac
      done
    else
      STOP=yes
    fi
  fi
fi

if [ -n "$STOP" ]; then
  if which invoke-rc.d >/dev/null 2>&1; then
    invoke-rc.d wdm stop
  else
    /etc/init.d/wdm stop || true
  fi
else
  if [ "$1" = "upgrade" -o "$1" = "failed-upgrade" ]; then
    touch /var/run/wdm.upgrade
  fi
fi

if [ "$1" = "remove" -o "$1" = "deconfigure" ]; then
  if [ -n "$HAVE_DEBCONF" ]; then
    # disown this question
    db_unregister shared/default-x-display-manager
    # does the question still exist?
    if db_get shared/default-x-display-manager; then
      if db_metaget shared/default-x-display-manager owners; then
        # FIXME - redo this part uses shell-lib.sh from xfree86
        #observe "X display managers now available are \"$OWNERS\""
	db_subst shared/default-x-display-manager choices "$RET"
      fi
      DEFAULT_DISPLAY_MANAGER=
      if db_get shared/default-x-display-manager; then
	DEFAULT_DISPLAY_MANAGER="$RET"
      fi
      # are we removing the currently selected display manager?
      if [ -n "$DEFAULT_DISPLAY_MANAGER" ]; then
	if [ "$THIS_PACKAGE" = "$DEFAULT_DISPLAY_MANAGER" ]; then
	  if [ -e "$DEFAULT_DISPLAY_MANAGER_FILE" ]; then
	    if db_get "$DEFAULT_DISPLAY_MANAGER/daemon_name"; then
              # does the display manager file reference the current default?
              # if so, remove it because it will now be wrong
	      if [ -n "$RET" ]; then
		if [ "$(cat "$DEFAULT_DISPLAY_MANAGER_FILE")" = "$RET" ]; then
		  rm "$DEFAULT_DISPLAY_MANAGER_FILE"
		fi
	      fi
	    fi
	  fi
          # ask the user to choose a new default
	  db_fset shared/default-x-display-manager seen false
	  db_input critical shared/default-x-display-manager || true
	  db_go
          # if the default display manager file doesn't exist, write it with
          # the path to the new default display manager
	  if [ ! -e "$DEFAULT_DISPLAY_MANAGER_FILE" ]; then
	    DEFAULT_DISPLAY_MANAGER=
	    if db_get shared/default-x-display-manager; then
	      DEFAULT_DISPLAY_MANAGER="$RET"
	    fi
	    if [ -n "$DEFAULT_DISPLAY_MANAGER" ]; then
              # FIXME - redo this part uses shell-lib.sh from xfree86
              #warn "new default display manager has been selected; " \
              #     "please be sure to run \"dpkg-reconfigure $RET\" " \
              #     "to ensure that it is configured"
              DAEMON_NAME=
              if db_get "$DEFAULT_DISPLAY_MANAGER"/daemon_name; then
		DAEMON_NAME="$RET"
              fi
              if [ ! -n "$DAEMON_NAME" ]; then
                # if we were unable to determine the name of the selected
                # daemon (for instance, if the selected default display
								# manager doesn't provide a daemon_name question), guess
		DAEMON_NAME=$(which "$DEFAULT_DISPLAY_MANAGER" 2>/dev/null)
		if [ ! -n "$DAEMON_NAME" ]; then
		  echo .
                  # FIXME - redo this part uses shell-lib.sh from xfree86
                  #warn "unable to determine path to default X display manager"
		  \
		    #     "$DEFAULT_DISPLAY_MANAGER; not updating" \
                  #     "$DEFAULT_DISPLAY_MANAGER_FILE"
		fi
              fi
              if [ -n "$DAEMON_NAME" ]; then
		echo "$DAEMON_NAME" > "$DEFAULT_DISPLAY_MANAGER_FILE"
              fi
	    fi
	  fi
	fi
      fi
    fi
  fi
fi




exit 0

# vim:set ai et sts=2 sw=2 tw=0:

# Local Variables:
# mode: shell-script
# sh-indentation: 2
# sh-basic-offset: 2
# End:
